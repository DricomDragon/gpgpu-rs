use crate::{Handler,kernels::{self,Kernel}};
use crate::Dim::{self,*};
use crate::descriptors::KernelDescriptor::{self,*};
use std::collections::HashMap;
use std::rc::Rc;

type Callback = Rc<(dyn Fn(&mut Handler, Vec<KernelDescriptor<String>>) -> crate::Result<()>)>;

pub struct Algorithm<S: Into<String>+Clone> {
    pub name: S,
    pub callback: Callback,
    pub needed_kernels: Vec<S>
}

pub fn convert<S: Into<String>+Clone>(a: &Algorithm<S>) -> Algorithm<String> {
    Algorithm {
        name: a.name.clone().into(),
        callback: a.callback.clone(),
        needed_kernels: a.needed_kernels.iter().map(|s| s.clone().into()).collect()
    }
}

pub fn algorithms() -> HashMap<String,Algorithm<&'static str>> {
    vec![
        Algorithm {
            name: "sum",
            callback: Rc::new(|h: &mut Handler, desc: Vec<KernelDescriptor<&str>>| {
                let dim = h.kernel_dim("algo_sum");
                let mut spacing = 2;
                match dim {
                    D1(x) => {
                        let l = x/spacing + if x%spacing > 1 { 1 } else { 0 };
                        let v = vec![Param("spacing".to_string(),spacing as f64)];
                        v.append(&desc);
                        h.run("algo_sum", D1(l), v)?;
                        while spacing<x {
                            spacing *= 2;
                            let l = x/spacing + if x%spacing > 1 { 1 } else { 0 };
                            h.run("algo_sum", D1(l), vec![Param("spacing",spacing as f64)])?;
                        }
                    },
                    _ => panic!("Dimensions higher than one are not handled yet.")
                }
                Ok(())
            }),
            needed_kernels: vec!["algo_sum"]
        }
    ].into_iter().map(|a| (a.name.clone().into(),a)).collect()
}
